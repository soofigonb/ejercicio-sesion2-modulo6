import O from "randexp";
const j = () => Math.floor(Math.random() * Math.pow(10, 13)), x = 0, h = 3, k = Number.MIN_SAFE_INTEGER, y = Number.MAX_SAFE_INTEGER, L = {
  array: {
    min: h,
    max: h
  },
  map: {
    min: h,
    max: h
  },
  set: {
    min: h,
    max: h
  },
  int: {
    min: -100,
    max: 100
  },
  float: {
    min: -100,
    max: 100
  },
  bigint: {
    min: -100n,
    max: 100n
  },
  date: {
    min: Date.UTC(1900, 0, 1),
    max: Date.UTC(2100, 11, 31)
  },
  string: {
    min: 15,
    max: 15,
    characterSet: "abcdefghijklmnopqrstuvwxyz-"
  },
  recursion: {
    min: 2,
    max: 2
  }
}, T = {
  array: {
    min: x,
    max: h
  },
  map: {
    min: x,
    max: h
  },
  set: {
    min: x,
    max: h
  },
  int: {
    min: k,
    max: y
  },
  float: {
    min: k,
    max: y
  },
  bigint: {
    min: BigInt(k),
    max: BigInt(y)
  },
  date: {
    min: Date.UTC(1900, 0, 1),
    max: Date.UTC(2100, 11, 31)
  },
  string: {
    min: 0,
    max: 100,
    characterSet: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.,/\\!@#$%^&*()_+=-{}[]|:;?<>~`'\""
  },
  recursion: {
    min: x,
    max: h
  }
}, u = (e) => {
  const t = () => {
  };
  return Object.defineProperty(t, "name", { value: e }), Object.defineProperty(t, "create", {
    value: () => ({ _def: { typeName: e } })
  }), t;
}, m = u("ZodString"), $ = u("ZodNumber"), z = u("ZodNaN"), G = u("ZodBigInt"), B = u("ZodBoolean"), F = u("ZodDate"), V = u("ZodSymbol"), K = u("ZodUndefined"), W = u("ZodNull"), M = u("ZodAny"), X = u("ZodUnknown"), q = u("ZodNever"), P = u("ZodVoid"), H = u("ZodArray"), J = u("ZodObject"), Q = u("ZodUnion"), Y = u("ZodDiscriminatedUnion"), tt = u("ZodIntersection"), et = u("ZodTuple"), nt = u("ZodRecord"), it = u("ZodMap"), st = u("ZodSet"), rt = u(
  "ZodFunction"
), _ = u("ZodLazy"), ot = u("ZodLiteral"), at = u("ZodEnum"), b = u("ZodEffects"), ct = u("ZodNativeEnum"), ut = u("ZodOptional"), lt = u("ZodNullable"), ht = u("ZodDefault");
u("ZodCatch");
const mt = u("ZodPromise"), dt = u("ZodBranded");
u("ZodPipeline");
const ft = u("ZodReadonly");
var f = /* @__PURE__ */ ((e) => (e.function = "function", e.number = "number", e.string = "string", e.nan = "nan", e.integer = "integer", e.float = "float", e.boolean = "boolean", e.date = "date", e.bigint = "bigint", e.symbol = "symbol", e.undefined = "undefined", e.null = "null", e.array = "array", e.object = "object", e.unknown = "unknown", e.promise = "promise", e.void = "void", e.never = "never", e.map = "map", e.set = "set", e))(f || {});
const S = (e) => {
  const t = typeof e;
  switch (t) {
    case "undefined":
    case "string":
    case "boolean":
    case "function":
    case "bigint":
    case "symbol":
      return t;
    case "number":
      return isNaN(e) ? "nan" : "number";
    case "object":
      return Array.isArray(e) ? "array" : e === null ? "null" : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? "promise" : typeof Map < "u" && e instanceof Map ? "map" : typeof Set < "u" && e instanceof Set ? "set" : typeof Date < "u" && e instanceof Date ? "date" : "object";
    default:
      return "unknown";
  }
}, E = {
  objectKeys: typeof Object.keys == "function" ? (e) => Object.keys(e) : (e) => {
    const t = [];
    for (const n in e)
      Object.prototype.hasOwnProperty.call(e, n) && t.push(n);
    return t;
  }
};
function pt(e) {
  return typeof e == "function";
}
function we(e) {
  return e;
}
class gt {
  constructor(t) {
    this.checks = t;
  }
  find(t) {
    return this.checks.find((n) => n.kind === t);
  }
  has(t) {
    return this.find(t) !== void 0;
  }
}
class xt {
  /* Period parameters */
  N = 624;
  M = 397;
  MATRIX_A = 2567483615;
  // constant vector a
  UPPER_MASK = 2147483648;
  // most significant w-r bits
  LOWER_MASK = 2147483647;
  // least significant r bits
  mt = new Array(this.N);
  // the array for the state vector
  mti = this.N + 1;
  // mti==N + 1 means mt[N] is not initialized
  constructor(t) {
    t === void 0 && (t = Math.floor(Math.random() * Math.pow(10, 13))), this.init_genrand(t);
  }
  /* initializes mt[N] with a seed */
  init_genrand(t) {
    for (this.mt[0] = t >>> 0, this.mti = 1; this.mti < this.N; this.mti++)
      t = this.mt[this.mti - 1] ^ this.mt[this.mti - 1] >>> 30, this.mt[this.mti] = (((t & 4294901760) >>> 16) * 1812433253 << 16) + (t & 65535) * 1812433253 + this.mti, this.mt[this.mti] >>>= 0;
  }
  /* initialize by an array with array-length */
  /* init_key is the array for initializing keys */
  /* key_length is its length */
  /* slight change for C++, 2004/2/26 */
  init_by_array(t, n) {
    let i = 1, s = 0, r, o;
    for (this.init_genrand(19650218), r = this.N > n ? this.N : n; r; r--)
      o = this.mt[i - 1] ^ this.mt[i - 1] >>> 30, this.mt[i] = (this.mt[i] ^ (((o & 4294901760) >>> 16) * 1664525 << 16) + (o & 65535) * 1664525) + // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      t[s] + s, this.mt[i] >>>= 0, i++, s++, i >= this.N && (this.mt[0] = this.mt[this.N - 1], i = 1), s >= n && (s = 0);
    for (r = this.N - 1; r; r--)
      o = this.mt[i - 1] ^ this.mt[i - 1] >>> 30, this.mt[i] = (this.mt[i] ^ (((o & 4294901760) >>> 16) * 1566083941 << 16) + (o & 65535) * 1566083941) - i, this.mt[i] >>>= 0, i++, i >= this.N && (this.mt[0] = this.mt[this.N - 1], i = 1);
    this.mt[0] = 2147483648;
  }
  /* generates a random number on [0,0xffffffff]-interval */
  genrand_int32() {
    let t;
    const n = [0, this.MATRIX_A];
    if (this.mti >= this.N) {
      let i;
      for (this.mti === this.N + 1 && this.init_genrand(5489), i = 0; i < this.N - this.M; i++)
        t = this.mt[i] & this.UPPER_MASK | this.mt[i + 1] & this.LOWER_MASK, this.mt[i] = this.mt[i + this.M] ^ t >>> 1 ^ n[t & 1];
      for (; i < this.N - 1; i++)
        t = this.mt[i] & this.UPPER_MASK | this.mt[i + 1] & this.LOWER_MASK, this.mt[i] = // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.mt[i + (this.M - this.N)] ^ t >>> 1 ^ n[t & 1];
      t = this.mt[this.N - 1] & this.UPPER_MASK | this.mt[0] & this.LOWER_MASK, this.mt[this.N - 1] = this.mt[this.M - 1] ^ t >>> 1 ^ n[t & 1], this.mti = 0;
    }
    return t = this.mt[this.mti++], t ^= t >>> 11, t ^= t << 7 & 2636928640, t ^= t << 15 & 4022730752, t ^= t >>> 18, t >>> 0;
  }
  /* generates a random number on [0,0x7fffffff]-interval */
  genrand_int31() {
    return this.genrand_int32() >>> 1;
  }
  /* generates a random number on [0,1]-real-interval */
  genrand_real1() {
    return this.genrand_int32() * (1 / 4294967295);
  }
  /* generates a random number on [0,1)-real-interval */
  random() {
    return this.genrand_int32() * (1 / 4294967296);
  }
  /* generates a random number on (0,1)-real-interval */
  genrand_real3() {
    return (this.genrand_int32() + 0.5) * (1 / 4294967296);
  }
  /* generates a random number on [0,1) with 53-bit resolution*/
  genrand_res53() {
    const t = this.genrand_int32() >>> 5, n = this.genrand_int32() >>> 6;
    return (t * 67108864 + n) * (1 / 9007199254740992);
  }
}
class vt {
  regex = /* @__PURE__ */ new WeakMap();
  string = /* @__PURE__ */ new Map();
  has(t) {
    return typeof t == "string" ? this.string.has(t) : this.regex.has(t);
  }
  set(t, n) {
    return typeof t == "string" ? this.string.set(t, n) : this.regex.set(t, n);
  }
  get(t, n) {
    let i = typeof t == "string" ? this.string.get(t) : this.regex.get(t);
    if (!i && n)
      i = n(new O(t)), this.set(t, i);
    else
      throw new Error(`No value for ${t} and no fallback available.`);
    return i;
  }
}
const w = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.", kt = [w], yt = w.replace(/\. /g, `.
`).split(`
`), Nt = w.toLowerCase().replace(/[,.]/, "").split(" ");
class bt {
  constructor(t) {
    this.defaults = t, this.mt = new xt(t.seed), this.regExRandInt = function(n, i) {
      return this.int({ min: n, max: i });
    }.bind(this);
  }
  mt;
  regExCache = new vt();
  regExRandInt;
  uuid() {
    let t = "";
    const n = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";
    let i = 0, s = this.unitInterval() * 4294967295 | 0;
    for (; i++ < 36; ) {
      const r = n[i - 1], o = s & 15, a = r == "x" ? o : o & 3 | 8;
      t += r == "-" || r == "4" ? r : a.toString(16), s = i % 8 == 0 ? this.unitInterval() * 4294967295 | 0 : s >> 4;
    }
    return t;
  }
  // https://en.wikipedia.org/wiki/Unit_interval
  unitInterval() {
    return this.mt.random();
  }
  from(t) {
    const n = t instanceof Set ? [...t] : t, i = 0, s = Math.max(i, n.length - 1), r = this.int({ min: i, max: s });
    return n[r];
  }
  shuffle(t) {
    const n = [...t];
    for (let i = n.length - 1; i > 0; i--) {
      const s = this.int({ min: 0, max: i }), r = n[i];
      n[i] = n[s], n[s] = r;
    }
    return n;
  }
  emoji() {
    const t = this.int({ min: 128513, max: 128591 });
    return String.fromCodePoint(t);
  }
  string(t) {
    let n = t.min ?? this.defaults.string.min, i = t.max ?? this.defaults.string.max;
    if (n < 0)
      throw new Error(
        `Minimum length of a string can't be less than 0: ${n}`
      );
    t.min && !t.max && (i = t.min), t.max && !t.min && (n = t.max);
    const s = this.int({ min: n, max: i });
    let r = "";
    for (let o = 0; o < s; o++)
      r += this.from(this.defaults.string.characterSet);
    return r;
  }
  float(t) {
    const n = t?.min ?? this.defaults.float.min, i = t?.max ?? this.defaults.float.max;
    if (n > i)
      throw new Error(`min ${n} can't be greater than max ${i}`);
    return this.unitInterval() * (i - n) + n;
  }
  int(t) {
    const n = t?.min ?? this.defaults.int.min, i = t?.max ?? this.defaults.int.max;
    if (n > i)
      throw new Error(`min ${n} can't be greater than max ${i}`);
    return Math.floor(this.unitInterval() * (i - n + 1)) + n;
  }
  bigInt(t) {
    const n = t?.min ?? this.defaults.bigint.min, i = t?.max ?? this.defaults.bigint.max;
    if (n >= i)
      throw new Error(`min ${n} can't be greater than max ${i}`);
    const s = i - n, r = s.toString().length;
    let o = "";
    for (; o.length < r; )
      o += this.unitInterval().toString().split(".")[1];
    o = o.slice(0, r);
    const a = "1" + "0".repeat(r), c = s * BigInt(o) / BigInt(a);
    return n + c;
  }
  lorem(t, n = "word") {
    const i = n === "word" ? Nt : n === "sentence" ? yt : kt;
    return Array.from({ length: t }, () => this.from(i)).join(" ");
  }
  boolean() {
    return this.unitInterval() < 0.5;
  }
  date(t) {
    const n = t?.min ?? this.defaults.date.min, i = t?.max ?? this.defaults.date.max;
    if (n > i)
      throw new Error(`min ${n} can't be greater than max ${i}`);
    return new Date(this.int({ min: n, max: i }));
  }
  cuid() {
    return this.regexp(/^[c][a-z0-9]{8}0000[a-z]{4}[a-z0-9]{8}$/);
  }
  cuid2() {
    return this.regexp(/^[a-z][a-z0-9]{23}$/);
  }
  ulid() {
    return this.regexp(/01[0-9A-HJKMNP-TV-Z]{24}/);
  }
  regexp(t) {
    return this.regExCache.get(t, (n) => (n.randInt = this.regExRandInt, n)).gen();
  }
}
class wt {
  constructor(t) {
    this.runner = t, this.random = new bt(t.defaults);
  }
  recursion = /* @__PURE__ */ new WeakMap();
  random;
  resolveValue(t) {
    const { initial: n, fallback: i } = t;
    if (n != null)
      return n;
    if ("conflict" in t) {
      const { conflict: s, resolve: r } = t;
      return s != null ? r({ fallback: i, conflict: s }) : i;
    } else
      return i;
  }
  n(t, n = this.runner.defaults.array) {
    const i = typeof n == "number" ? n : this.random.int(n);
    return Array.from({ length: i }, (s, r) => t(r));
  }
  ifNotNever(t, n) {
    !t || t._def.typeName === "ZodNever" || n(t);
  }
  recursionCheck(t, n) {
    if (this.isType(_, t)) {
      const i = this.recursion.get(t._def.getter) ?? 0, s = this.random.int(this.runner.defaults.recursion);
      if (i >= s)
        return;
    }
    n(t);
  }
  isType(t, n) {
    return pt(t) ? n._def.typeName === t.name : (
      // If our generator was created with an instance, make sure it matches
      // the schema we're trying to generate.
      // This is particularly important for z.custom schemas.
      n === t
    );
  }
  checks(t) {
    return new gt(t);
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  noop() {
  }
}
class St {
  constructor(t, n) {
    this.transformer = t, this.defaults = {
      ...t.transformerDefaults,
      ...t.instanceDefaults,
      ...n
    }, this.utils = new wt(this);
  }
  defaults;
  utils;
  fromSchema(t, n = { path: [] }) {
    const i = this, s = t._def, r = this.transformer.generators.find((o) => !(o.schema && !i.utils.isType(o.schema, t) || o.filter && !o.filter({ schema: t, def: s, transform: i, context: n })));
    return this.shouldHaveMatch(t, r), r.output({ schema: t, def: s, transform: i, context: n });
  }
  shouldHaveMatch(t, n) {
    if (!n)
      throw this.transformer.missingGeneratorError(t);
  }
}
class I {
  constructor(t) {
    this.instanceDefaults = t, this.instanceDefaults = { seed: j(), ...t };
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  extend(t) {
    const n = Array.isArray(t) ? t : [t];
    return this.generators = n.concat(this.generators), this;
  }
  fromSchema(t, n) {
    return new St(this, n).fromSchema(t);
  }
  missingGeneratorError(t) {
    return new Error(`No generator found for ${t.constructor.name}.`);
  }
}
class Et extends I {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  generators = [];
  transformerDefaults = L;
}
class Zt extends I {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  generators = [];
  transformerDefaults = T;
}
const Gt = {
  schema: M,
  // @TODO: implement a more robust any generator.
  output: () => "ZodAny"
}, Mt = {
  schema: H,
  output: ({ def: e, transform: t, context: n }) => {
    const i = e.minLength?.value ?? e.exactLength?.value, s = e.maxLength?.value ?? e.exactLength?.value, r = t.utils.resolveValue({
      initial: i,
      fallback: t.defaults.array.min,
      conflict: s,
      resolve: (c) => Math.min(c.fallback, c.conflict)
    }), o = t.utils.resolveValue({
      initial: s,
      fallback: t.defaults.array.max,
      conflict: i,
      resolve: (c) => Math.max(c.fallback, c.conflict)
    }), a = [];
    return t.utils.ifNotNever(e.type, (c) => {
      t.utils.recursionCheck(c, () => {
        t.utils.n(
          (d) => a.push(
            t.fromSchema(c, {
              ...n,
              path: [...n.path, d]
            })
          ),
          { min: r, max: o }
        );
      });
    }), a;
  }
}, _t = {
  schema: G,
  filter: ({ def: e, transform: t }) => !t.utils.checks(e.checks).has("multipleOf"),
  output: ({ def: e, transform: t }) => {
    const n = t.utils.checks(e.checks), i = n.find("min")?.value, s = n.find("max")?.value;
    return t.utils.random.bigInt({ min: i, max: s });
  }
}, It = {
  schema: G,
  filter: ({ def: e, transform: t }) => t.utils.checks(e.checks).has("multipleOf"),
  output: ({ def: e, transform: t }) => {
    const n = t.utils.checks(e.checks), i = n.find("min")?.value ?? t.defaults.bigint.min, s = n.find("max")?.value ?? t.defaults.bigint.max, r = n.find("multipleOf").value ?? 1, o = i / r, a = s / r;
    return t.utils.random.bigInt({ min: o, max: a }) * r;
  }
}, At = {
  schema: B,
  output: ({ transform: e }) => e.utils.random.boolean()
}, Rt = {
  schema: dt,
  output: ({ def: e, transform: t, context: n }) => t.fromSchema(e.type, n)
}, Ct = {
  schema: F,
  output: ({ def: e, transform: t }) => {
    const n = t.utils.checks(e.checks), i = n.find("min")?.value ?? t.defaults.date.min, s = n.find("max")?.value ?? t.defaults.date.max;
    return new Date(t.utils.random.int({ min: i, max: s }));
  }
}, Ut = {
  schema: ht,
  output: ({ def: e, transform: t }) => t.utils.random.boolean() ? e.defaultValue() : t.fromSchema(e.innerType)
}, Dt = {
  schema: b,
  filter: ({ def: e }) => e.effect.type === "transform",
  output: ({ def: e, transform: t, context: n }) => {
    if (e.effect.type !== "transform")
      throw new Error("Must be a transform effect.");
    const i = t.fromSchema(e.schema, n);
    return e.effect.transform(i, {
      addIssue: t.utils.noop,
      // @TODO: Verify that path is not needed here.
      path: []
    });
  }
}, Ot = {
  schema: b,
  filter: ({ def: e }) => e.effect.type === "preprocess",
  output: ({ def: e, transform: t, context: n }) => {
    if (e.effect.type !== "preprocess")
      throw new Error("Must be a preprocess effect.");
    return t.fromSchema(e.schema, n);
  }
}, jt = {
  schema: b,
  filter: ({ def: e }) => e.effect.type === "refinement",
  output: ({ def: e, transform: t, context: n }) => {
    if (e.effect.type !== "refinement")
      throw new Error("Must be a refinement effect.");
    const { schema: i } = e;
    return console.warn(
      `Because refinements use custom validations, we have no way to accurately manufacture acceptable values. Using the parent type (${i._def.typeName}) to approximate the result.`
    ), t.fromSchema(i, n);
  }
}, Lt = {
  schema: at,
  output: ({ def: e, transform: t }) => t.utils.random.from(e.values)
}, Tt = {
  schema: ct,
  output: ({ def: e, transform: t }) => {
    const n = e.values ?? {}, i = Object.keys(n).filter((s) => Number.isNaN(Number(s))).map((s) => n[s]);
    return t.utils.random.from(i);
  }
}, $t = {
  schema: rt,
  output: ({ transform: e }) => e.utils.noop
}, zt = {
  schema: tt,
  output: ({ def: e, transform: t, context: n }) => {
    const i = t.fromSchema(e.left, n), s = t.fromSchema(e.right, n), r = N(i, s);
    if (!r.valid)
      throw new Error("Intersection is not valid.");
    return r.data;
  }
};
function N(e, t) {
  const n = S(e), i = S(t);
  if (e === t)
    return { valid: !0, data: e };
  if (n === f.object && i === f.object) {
    const s = E.objectKeys(t), r = E.objectKeys(e).filter((a) => s.indexOf(a) !== -1), o = { ...e, ...t };
    for (const a of r) {
      const c = N(e[a], t[a]);
      if (!c.valid)
        return { valid: !1 };
      o[a] = c.data;
    }
    return { valid: !0, data: o };
  } else if (n === f.array && i === f.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const s = [];
    for (let r = 0; r < e.length; r++) {
      const o = e[r], a = t[r], c = N(o, a);
      if (!c.valid)
        return { valid: !1 };
      s.push(c.data);
    }
    return { valid: !0, data: s };
  } else
    return n === f.date && i === f.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
const Bt = {
  schema: _,
  output: ({ def: e, transform: t, context: n }) => {
    const i = t.utils.recursion.get(e.getter) ?? 0;
    return t.utils.recursion.set(e.getter, i + 1), t.fromSchema(e.getter(), n);
  }
}, Ft = {
  schema: ot,
  output: ({ def: e }) => e.value
}, Vt = {
  schema: it,
  output: ({ def: e, transform: t, context: n }) => {
    const i = e.keyType, s = e.valueType, r = /* @__PURE__ */ new Map();
    return t.utils.ifNotNever(i, (o) => {
      t.utils.ifNotNever(s, (a) => {
        t.utils.recursionCheck(a, () => {
          t.utils.n(() => {
            const c = t.fromSchema(o, n), d = t.fromSchema(a, {
              ...n,
              path: [...n.path, c]
            });
            r.set(c, d);
          }, t.defaults.map);
        });
      });
    }), r;
  }
}, Kt = {
  schema: z,
  output: () => NaN
}, Wt = {
  schema: q,
  output: () => {
    throw new Error(
      "Never is a sanity check by Zod to ensure fields don't exist. If we've reached this point, something went wrong during fixture generation."
    );
  }
}, Xt = {
  schema: W,
  output: () => null
}, qt = {
  schema: lt,
  output: ({ def: e, transform: t, context: n }) => {
    let i = null;
    return t.utils.random.boolean() && t.utils.recursionCheck(e.innerType, () => {
      i = t.fromSchema(e.innerType, n);
    }), i;
  }
}, Pt = {
  schema: $,
  output: ({ def: e, transform: t }) => {
    const n = t.utils.checks(e.checks), i = n.find("min") ?? {
      value: t.defaults.float.min,
      inclusive: !0
    }, s = n.find("max") ?? {
      value: t.defaults.float.max,
      inclusive: !0
    }, r = i.inclusive ? i.value : i.value + 1, o = s.inclusive ? s.value : s.value - 1, a = n.find("multipleOf")?.value, c = n.has("int"), d = n.has("finite");
    let l = c ? t.utils.random.int({ min: r, max: o }) : t.utils.random.float({ min: r, max: o });
    if (a !== void 0 && (l = Math.round(l / a) * a, l < r && (l += a), l > o && (l -= a), a % 1 !== 0)) {
      const v = a.toString().split(".")[1]?.length;
      l = Number(l.toFixed(v));
    }
    return d && (l === 1 / 0 ? l = Number.MAX_VALUE : l === -1 / 0 && (l = Number.MIN_VALUE)), l;
  }
}, Ht = {
  schema: J,
  output: ({ def: e, transform: t, context: n }) => {
    const i = e.shape(), s = {};
    for (const o in i)
      t.utils.ifNotNever(i[o], (a) => {
        t.utils.recursionCheck(a, () => {
          s[o] = t.fromSchema(a, {
            ...n,
            path: [...n.path, o]
          });
        });
      });
    if (e.unknownKeys === "passthrough" || e.catchall._def.typeName !== "ZodNever") {
      const o = t.utils.random.lorem(1, "word"), a = e.catchall._def.typeName === "ZodNever" ? M.create() : e.catchall;
      s[o] = t.fromSchema(a, {
        ...n,
        path: [...n.path, o]
      });
    }
    return s;
  }
}, Jt = {
  schema: nt,
  output: ({ def: e, transform: t, context: n }) => {
    const i = {};
    return t.utils.ifNotNever(e.keyType, (s) => {
      t.utils.ifNotNever(e.valueType, (r) => {
        t.utils.recursionCheck(r, () => {
          t.utils.n(() => {
            const o = t.fromSchema(s, n), a = t.fromSchema(r, {
              ...n,
              path: [...n.path, o]
            });
            i[o] = a;
          });
        });
      });
    }), i;
  }
}, Qt = {
  schema: ut,
  output: ({ def: e, transform: t, context: n }) => {
    let i;
    return t.utils.random.boolean() && t.utils.recursionCheck(e.innerType, () => {
      i = t.fromSchema(e.innerType, n);
    }), i;
  }
}, Yt = {
  schema: mt,
  output: ({ def: e, transform: t, context: n }) => {
    let i;
    return t.utils.recursionCheck(e.type, () => {
      i = t.fromSchema(e.type, n);
    }), Promise.resolve(i);
  }
}, te = {
  schema: ft,
  output: ({ transform: e, def: t }) => {
    const n = e.fromSchema(t.innerType);
    return Object.freeze(n);
  }
}, ee = {
  schema: st,
  output: ({ def: e, transform: t, context: n }) => {
    const i = e.minSize?.value, s = e.maxSize?.value, r = t.utils.resolveValue({
      initial: i,
      fallback: t.defaults.set.min,
      conflict: s,
      resolve: (c) => Math.min(c.fallback, c.conflict)
    }), o = t.utils.resolveValue({
      initial: s,
      fallback: t.defaults.set.max,
      conflict: i,
      resolve: (c) => Math.max(c.fallback, c.conflict)
    }), a = /* @__PURE__ */ new Set();
    return t.utils.ifNotNever(e.valueType, (c) => {
      t.utils.recursionCheck(c, () => {
        t.utils.n(
          () => {
            a.add(
              t.fromSchema(c, {
                ...n,
                path: [...n.path, a.size]
              })
            );
          },
          { min: r, max: o }
        );
      });
    }), a;
  }
}, Z = (e) => `^.{${e.length}}`, ne = (e) => `.{${e.length}}$`;
function p(e, t, n) {
  const i = e.utils.checks(t.checks);
  let s = i.find("max")?.value, r = i.find("min")?.value ?? 0;
  const o = i.find("length")?.value, a = i.find("includes")?.value, c = i.find("startsWith")?.value, d = i.find("endsWith")?.value, l = i.has("emoji"), v = i.has("trim"), C = i.has("toUpperCase"), U = i.has("toLowerCase");
  if (o && (r = o, s = o), r != null && n.length < r) {
    const g = r - n.length;
    n += e.utils.random.string({ min: g, max: g });
  }
  if (s != null && (n = n.slice(0, s)), a) {
    const g = c ? Z(c) : "";
    n = n.replace(
      new RegExp(`(${g}).{${a.length}}`),
      (Ne, D) => D + a
    );
  }
  return c && (n = n.replace(new RegExp(Z(c)), c)), d && (n = n.replace(new RegExp(ne(d)), d)), C ? n = n.toUpperCase() : U && (n = n.toLowerCase()), v && (n = n.trim()), l && (n = n.replace(/./g, () => e.utils.random.emoji())), s ? n.slice(0, s) : n;
}
const ie = {
  schema: m,
  output: ({ def: e, transform: t }) => {
    const n = t.utils.checks(e.checks);
    let i = n.find("min")?.value, s = n.find("max")?.value;
    const r = n.find("length");
    return r && (i = r.value, s = r.value), p(
      t,
      e,
      t.utils.random.string({ min: i, max: s })
    );
  }
}, se = {
  schema: m,
  filter: ({ def: e, transform: t }) => t.utils.checks(e.checks).has("ulid"),
  output: ({ def: e, transform: t }) => p(t, e, t.utils.random.ulid())
}, re = {
  schema: m,
  filter: ({ def: e, transform: t }) => t.utils.checks(e.checks).has("url"),
  output: ({ def: e, transform: t }) => p(
    t,
    e,
    `https://${t.utils.random.lorem(1)}.com`
  )
}, oe = {
  schema: m,
  filter: ({ def: e, transform: t }) => t.utils.checks(e.checks).has("uuid"),
  output: ({ transform: e }) => e.utils.random.uuid()
}, ae = {
  schema: m,
  filter: ({ def: e, transform: t }) => t.utils.checks(e.checks).has("email"),
  output: ({ def: e, transform: t }) => p(t, e, "rando@email.com")
}, ce = {
  schema: m,
  filter: ({ def: e, transform: t }) => t.utils.checks(e.checks).has("cuid"),
  output: ({ def: e, transform: t }) => p(t, e, t.utils.random.cuid())
}, ue = {
  schema: m,
  filter: ({ def: e, transform: t }) => t.utils.checks(e.checks).has("ip"),
  output: ({ def: e, transform: t }) => (t.utils.checks(e.checks).find("ip")?.version ?? t.utils.random.from(["v4", "v6"])) === "v4" ? t.utils.n(() => t.utils.random.int({ min: 1, max: 255 }), 4).join(".") : t.utils.n(
    () => t.utils.random.int({ min: 0, max: 65535 }).toString(16),
    8
  ).join(":")
}, le = {
  schema: m,
  filter: ({ def: e, transform: t }) => t.utils.checks(e.checks).has("cuid2"),
  output: ({ def: e, transform: t }) => p(t, e, t.utils.random.cuid2())
}, he = {
  schema: m,
  filter: ({ def: e, transform: t }) => t.utils.checks(e.checks).has("datetime"),
  output: ({ transform: e }) => e.utils.random.date().toISOString()
}, me = {
  schema: m,
  filter: ({ def: e, transform: t }) => t.utils.checks(e.checks).has("regex"),
  output: ({ def: e, transform: t }) => {
    const n = t.utils.checks(e.checks).find("regex")?.regex;
    if (!n)
      throw new Error("RegexGenerator: regex pattern not found");
    return p(t, e, t.utils.random.regexp(n));
  }
}, de = {
  schema: V,
  output: ({ transform: e }) => Symbol.for(e.utils.random.lorem(1, "word"))
}, fe = {
  schema: et,
  output: ({ def: e, transform: t, context: n }) => {
    const i = [];
    e.items.forEach((r, o) => {
      t.utils.ifNotNever(r, (a) => {
        t.utils.recursionCheck(a, () => {
          i.push(
            t.fromSchema(a, {
              ...n,
              path: [...n.path, o]
            })
          );
        });
      });
    });
    const s = [];
    return t.utils.ifNotNever(e.rest, (r) => {
      t.utils.recursionCheck(r, () => {
        t.utils.n(
          (o) => s.push(
            t.fromSchema(r, {
              ...n,
              path: [...n.path, i.length + o]
            })
          ),
          1
        );
      });
    }), [...i, ...s];
  }
}, pe = {
  schema: K,
  output: () => {
  }
}, ge = {
  schema: P,
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  output: () => {
  }
}, xe = {
  schema: Q,
  output: ({ def: e, transform: t, context: n }) => {
    const i = t.utils.random.from(e.options);
    return t.fromSchema(i, n);
  }
}, ve = {
  schema: Y,
  output: ({ def: e, transform: t, context: n }) => {
    const i = t.utils.random.from(e.options);
    return t.fromSchema(i, n);
  }
}, ke = {
  schema: X,
  // @TODO: implement a more robust unknown generator.
  output: () => "ZodUnknown"
}, A = [
  Gt,
  ke,
  Qt,
  ue,
  se,
  Mt,
  _t,
  It,
  At,
  Ct,
  Lt,
  Tt,
  $t,
  zt,
  Ft,
  Vt,
  Kt,
  Xt,
  Pt,
  Ht,
  Jt,
  ee,
  oe,
  ce,
  le,
  ae,
  re,
  he,
  me,
  qt,
  fe,
  pe,
  xe,
  ve,
  Dt,
  Ot,
  jt,
  Yt,
  de,
  Bt,
  Rt,
  ge,
  Wt,
  ie,
  Ut,
  te
];
function R(e) {
  const t = [
    `No generator found for ${e.constructor.name}.`,
    "",
    "For z.custom, refer to the documentation https://github.com/timdeschryver/zod-fixture.",
    "If you still believe this is an error, please open an issue at https://github.com/timdeschryver/zod-fixture/issues/new.",
    ""
  ].join(`
`);
  return new Error(t);
}
class ye extends Et {
  generators = A;
  missingGeneratorError = R;
}
class Se extends Zt {
  generators = A;
  missingGeneratorError = R;
}
function Ee(e, t) {
  return new ye(t).fromSchema(e);
}
export {
  Gt as AnyGenerator,
  Mt as ArrayGenerator,
  _t as BigIntGenerator,
  It as BigIntMultipleOfGenerator,
  At as BooleanGenerator,
  Rt as BrandedGenerator,
  ye as ConstrainedFixture,
  Et as ConstrainedTransformer,
  le as Cuid2Generator,
  ce as CuidGenerator,
  A as DEFAULT_FIXTURE_GENERATORS,
  Ct as DateGenerator,
  he as DateTimeGenerator,
  Ut as DefaultGenerator,
  ve as DiscriminatedUnionGenerator,
  ae as EmailGenerator,
  Lt as EnumGenerator,
  ye as Fixture,
  $t as FunctionGenerator,
  we as Generator,
  zt as IntersectionGenerator,
  ue as IpGenerator,
  Bt as LazyGenerator,
  Ft as LiteralGenerator,
  Vt as MapGenerator,
  Kt as NanGenerator,
  Tt as NativeEnumGenerator,
  Wt as NeverGenerator,
  Xt as NullGenerator,
  qt as NullableGenerator,
  Pt as NumberGenerator,
  Ht as ObjectGenerator,
  Qt as OptionalGenerator,
  Ot as PreprocessGenerator,
  Yt as PromiseGenerator,
  te as ReadonlyGenerator,
  Jt as RecordGenerator,
  jt as RefinementGenerator,
  me as RegexGenerator,
  ee as SetGenerator,
  ie as StringGenerator,
  de as SymbolGenerator,
  Dt as TransformGenerator,
  I as Transformer,
  fe as TupleGenerator,
  se as UlidGenerator,
  Se as UnconstrainedFixture,
  Zt as UnconstrainedTransformer,
  pe as UndefinedGenerator,
  xe as UnionGenerator,
  ke as UnknownGenerator,
  re as UrlGenerator,
  oe as UuidGenerator,
  ge as VoidGenerator,
  Ee as createFixture
};
