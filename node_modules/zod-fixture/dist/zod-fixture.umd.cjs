(function(o,g){typeof exports=="object"&&typeof module<"u"?g(exports,require("randexp")):typeof define=="function"&&define.amd?define(["exports","randexp"],g):(o=typeof globalThis<"u"?globalThis:o||self,g(o["zod-fixture"]={},o.RandExp))})(this,function(o,g){"use strict";const _t=()=>Math.floor(Math.random()*Math.pow(10,13)),v=Number.MIN_SAFE_INTEGER,y=Number.MAX_SAFE_INTEGER,Mt={array:{min:3,max:3},map:{min:3,max:3},set:{min:3,max:3},int:{min:-100,max:100},float:{min:-100,max:100},bigint:{min:-100n,max:100n},date:{min:Date.UTC(1900,0,1),max:Date.UTC(2100,11,31)},string:{min:15,max:15,characterSet:"abcdefghijklmnopqrstuvwxyz-"},recursion:{min:2,max:2}},Zt={array:{min:0,max:3},map:{min:0,max:3},set:{min:0,max:3},int:{min:v,max:y},float:{min:v,max:y},bigint:{min:BigInt(v),max:BigInt(y)},date:{min:Date.UTC(1900,0,1),max:Date.UTC(2100,11,31)},string:{min:0,max:100,characterSet:"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.,/\\!@#$%^&*()_+=-{}[]|:;?<>~`'\""},recursion:{min:0,max:3}},u=e=>{const t=()=>{};return Object.defineProperty(t,"name",{value:e}),Object.defineProperty(t,"create",{value:()=>({_def:{typeName:e}})}),t},m=u("ZodString"),At=u("ZodNumber"),Rt=u("ZodNaN"),w=u("ZodBigInt"),Tt=u("ZodBoolean"),Ut=u("ZodDate"),Lt=u("ZodSymbol"),Ct=u("ZodUndefined"),Dt=u("ZodNull"),_=u("ZodAny"),Ot=u("ZodUnknown"),jt=u("ZodNever"),Ft=u("ZodVoid"),$t=u("ZodArray"),Bt=u("ZodObject"),zt=u("ZodUnion"),Xt=u("ZodDiscriminatedUnion"),Vt=u("ZodIntersection"),Kt=u("ZodTuple"),Wt=u("ZodRecord"),Pt=u("ZodMap"),qt=u("ZodSet"),Ht=u("ZodFunction"),M=u("ZodLazy"),Jt=u("ZodLiteral"),Qt=u("ZodEnum"),G=u("ZodEffects"),Yt=u("ZodNativeEnum"),te=u("ZodOptional"),ee=u("ZodNullable"),ne=u("ZodDefault");u("ZodCatch");const ie=u("ZodPromise"),re=u("ZodBranded");u("ZodPipeline");const se=u("ZodReadonly");var f=(e=>(e.function="function",e.number="number",e.string="string",e.nan="nan",e.integer="integer",e.float="float",e.boolean="boolean",e.date="date",e.bigint="bigint",e.symbol="symbol",e.undefined="undefined",e.null="null",e.array="array",e.object="object",e.unknown="unknown",e.promise="promise",e.void="void",e.never="never",e.map="map",e.set="set",e))(f||{});const Z=e=>{const t=typeof e;switch(t){case"undefined":case"string":case"boolean":case"function":case"bigint":case"symbol":return t;case"number":return isNaN(e)?"nan":"number";case"object":return Array.isArray(e)?"array":e===null?"null":e.then&&typeof e.then=="function"&&e.catch&&typeof e.catch=="function"?"promise":typeof Map<"u"&&e instanceof Map?"map":typeof Set<"u"&&e instanceof Set?"set":typeof Date<"u"&&e instanceof Date?"date":"object";default:return"unknown"}},A={objectKeys:typeof Object.keys=="function"?e=>Object.keys(e):e=>{const t=[];for(const n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.push(n);return t}};function oe(e){return typeof e=="function"}function ae(e){return e}class ce{constructor(t){this.checks=t}find(t){return this.checks.find(n=>n.kind===t)}has(t){return this.find(t)!==void 0}}class ue{N=624;M=397;MATRIX_A=2567483615;UPPER_MASK=2147483648;LOWER_MASK=2147483647;mt=new Array(this.N);mti=this.N+1;constructor(t){t===void 0&&(t=Math.floor(Math.random()*Math.pow(10,13))),this.init_genrand(t)}init_genrand(t){for(this.mt[0]=t>>>0,this.mti=1;this.mti<this.N;this.mti++)t=this.mt[this.mti-1]^this.mt[this.mti-1]>>>30,this.mt[this.mti]=(((t&4294901760)>>>16)*1812433253<<16)+(t&65535)*1812433253+this.mti,this.mt[this.mti]>>>=0}init_by_array(t,n){let i=1,r=0,s,a;for(this.init_genrand(19650218),s=this.N>n?this.N:n;s;s--)a=this.mt[i-1]^this.mt[i-1]>>>30,this.mt[i]=(this.mt[i]^(((a&4294901760)>>>16)*1664525<<16)+(a&65535)*1664525)+t[r]+r,this.mt[i]>>>=0,i++,r++,i>=this.N&&(this.mt[0]=this.mt[this.N-1],i=1),r>=n&&(r=0);for(s=this.N-1;s;s--)a=this.mt[i-1]^this.mt[i-1]>>>30,this.mt[i]=(this.mt[i]^(((a&4294901760)>>>16)*1566083941<<16)+(a&65535)*1566083941)-i,this.mt[i]>>>=0,i++,i>=this.N&&(this.mt[0]=this.mt[this.N-1],i=1);this.mt[0]=2147483648}genrand_int32(){let t;const n=[0,this.MATRIX_A];if(this.mti>=this.N){let i;for(this.mti===this.N+1&&this.init_genrand(5489),i=0;i<this.N-this.M;i++)t=this.mt[i]&this.UPPER_MASK|this.mt[i+1]&this.LOWER_MASK,this.mt[i]=this.mt[i+this.M]^t>>>1^n[t&1];for(;i<this.N-1;i++)t=this.mt[i]&this.UPPER_MASK|this.mt[i+1]&this.LOWER_MASK,this.mt[i]=this.mt[i+(this.M-this.N)]^t>>>1^n[t&1];t=this.mt[this.N-1]&this.UPPER_MASK|this.mt[0]&this.LOWER_MASK,this.mt[this.N-1]=this.mt[this.M-1]^t>>>1^n[t&1],this.mti=0}return t=this.mt[this.mti++],t^=t>>>11,t^=t<<7&2636928640,t^=t<<15&4022730752,t^=t>>>18,t>>>0}genrand_int31(){return this.genrand_int32()>>>1}genrand_real1(){return this.genrand_int32()*(1/4294967295)}random(){return this.genrand_int32()*(1/4294967296)}genrand_real3(){return(this.genrand_int32()+.5)*(1/4294967296)}genrand_res53(){const t=this.genrand_int32()>>>5,n=this.genrand_int32()>>>6;return(t*67108864+n)*(1/9007199254740992)}}class le{regex=new WeakMap;string=new Map;has(t){return typeof t=="string"?this.string.has(t):this.regex.has(t)}set(t,n){return typeof t=="string"?this.string.set(t,n):this.regex.set(t,n)}get(t,n){let i=typeof t=="string"?this.string.get(t):this.regex.get(t);if(!i&&n)i=n(new g(t)),this.set(t,i);else throw new Error(`No value for ${t} and no fallback available.`);return i}}const N="Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.",he=[N],me=N.replace(/\. /g,`.
`).split(`
`),de=N.toLowerCase().replace(/[,.]/,"").split(" ");class fe{constructor(t){this.defaults=t,this.mt=new ue(t.seed),this.regExRandInt=function(n,i){return this.int({min:n,max:i})}.bind(this)}mt;regExCache=new le;regExRandInt;uuid(){let t="";const n="xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";let i=0,r=this.unitInterval()*4294967295|0;for(;i++<36;){const s=n[i-1],a=r&15,c=s=="x"?a:a&3|8;t+=s=="-"||s=="4"?s:c.toString(16),r=i%8==0?this.unitInterval()*4294967295|0:r>>4}return t}unitInterval(){return this.mt.random()}from(t){const n=t instanceof Set?[...t]:t,i=0,r=Math.max(i,n.length-1),s=this.int({min:i,max:r});return n[s]}shuffle(t){const n=[...t];for(let i=n.length-1;i>0;i--){const r=this.int({min:0,max:i}),s=n[i];n[i]=n[r],n[r]=s}return n}emoji(){const t=this.int({min:128513,max:128591});return String.fromCodePoint(t)}string(t){let n=t.min??this.defaults.string.min,i=t.max??this.defaults.string.max;if(n<0)throw new Error(`Minimum length of a string can't be less than 0: ${n}`);t.min&&!t.max&&(i=t.min),t.max&&!t.min&&(n=t.max);const r=this.int({min:n,max:i});let s="";for(let a=0;a<r;a++)s+=this.from(this.defaults.string.characterSet);return s}float(t){const n=t?.min??this.defaults.float.min,i=t?.max??this.defaults.float.max;if(n>i)throw new Error(`min ${n} can't be greater than max ${i}`);return this.unitInterval()*(i-n)+n}int(t){const n=t?.min??this.defaults.int.min,i=t?.max??this.defaults.int.max;if(n>i)throw new Error(`min ${n} can't be greater than max ${i}`);return Math.floor(this.unitInterval()*(i-n+1))+n}bigInt(t){const n=t?.min??this.defaults.bigint.min,i=t?.max??this.defaults.bigint.max;if(n>=i)throw new Error(`min ${n} can't be greater than max ${i}`);const r=i-n,s=r.toString().length;let a="";for(;a.length<s;)a+=this.unitInterval().toString().split(".")[1];a=a.slice(0,s);const c="1"+"0".repeat(s),l=r*BigInt(a)/BigInt(c);return n+l}lorem(t,n="word"){const i=n==="word"?de:n==="sentence"?me:he;return Array.from({length:t},()=>this.from(i)).join(" ")}boolean(){return this.unitInterval()<.5}date(t){const n=t?.min??this.defaults.date.min,i=t?.max??this.defaults.date.max;if(n>i)throw new Error(`min ${n} can't be greater than max ${i}`);return new Date(this.int({min:n,max:i}))}cuid(){return this.regexp(/^[c][a-z0-9]{8}0000[a-z]{4}[a-z0-9]{8}$/)}cuid2(){return this.regexp(/^[a-z][a-z0-9]{23}$/)}ulid(){return this.regexp(/01[0-9A-HJKMNP-TV-Z]{24}/)}regexp(t){return this.regExCache.get(t,n=>(n.randInt=this.regExRandInt,n)).gen()}}class pe{constructor(t){this.runner=t,this.random=new fe(t.defaults)}recursion=new WeakMap;random;resolveValue(t){const{initial:n,fallback:i}=t;if(n!=null)return n;if("conflict"in t){const{conflict:r,resolve:s}=t;return r!=null?s({fallback:i,conflict:r}):i}else return i}n(t,n=this.runner.defaults.array){const i=typeof n=="number"?n:this.random.int(n);return Array.from({length:i},(r,s)=>t(s))}ifNotNever(t,n){!t||t._def.typeName==="ZodNever"||n(t)}recursionCheck(t,n){if(this.isType(M,t)){const i=this.recursion.get(t._def.getter)??0,r=this.random.int(this.runner.defaults.recursion);if(i>=r)return}n(t)}isType(t,n){return oe(t)?n._def.typeName===t.name:n===t}checks(t){return new ce(t)}noop(){}}class ge{constructor(t,n){this.transformer=t,this.defaults={...t.transformerDefaults,...t.instanceDefaults,...n},this.utils=new pe(this)}defaults;utils;fromSchema(t,n={path:[]}){const i=this,r=t._def,s=this.transformer.generators.find(a=>!(a.schema&&!i.utils.isType(a.schema,t)||a.filter&&!a.filter({schema:t,def:r,transform:i,context:n})));return this.shouldHaveMatch(t,s),s.output({schema:t,def:r,transform:i,context:n})}shouldHaveMatch(t,n){if(!n)throw this.transformer.missingGeneratorError(t)}}class k{constructor(t){this.instanceDefaults=t,this.instanceDefaults={seed:_t(),...t}}extend(t){const n=Array.isArray(t)?t:[t];return this.generators=n.concat(this.generators),this}fromSchema(t,n){return new ge(this,n).fromSchema(t)}missingGeneratorError(t){return new Error(`No generator found for ${t.constructor.name}.`)}}class R extends k{generators=[];transformerDefaults=Mt}class T extends k{generators=[];transformerDefaults=Zt}const U={schema:_,output:()=>"ZodAny"},L={schema:$t,output:({def:e,transform:t,context:n})=>{const i=e.minLength?.value??e.exactLength?.value,r=e.maxLength?.value??e.exactLength?.value,s=t.utils.resolveValue({initial:i,fallback:t.defaults.array.min,conflict:r,resolve:l=>Math.min(l.fallback,l.conflict)}),a=t.utils.resolveValue({initial:r,fallback:t.defaults.array.max,conflict:i,resolve:l=>Math.max(l.fallback,l.conflict)}),c=[];return t.utils.ifNotNever(e.type,l=>{t.utils.recursionCheck(l,()=>{t.utils.n(d=>c.push(t.fromSchema(l,{...n,path:[...n.path,d]})),{min:s,max:a})})}),c}},C={schema:w,filter:({def:e,transform:t})=>!t.utils.checks(e.checks).has("multipleOf"),output:({def:e,transform:t})=>{const n=t.utils.checks(e.checks),i=n.find("min")?.value,r=n.find("max")?.value;return t.utils.random.bigInt({min:i,max:r})}},D={schema:w,filter:({def:e,transform:t})=>t.utils.checks(e.checks).has("multipleOf"),output:({def:e,transform:t})=>{const n=t.utils.checks(e.checks),i=n.find("min")?.value??t.defaults.bigint.min,r=n.find("max")?.value??t.defaults.bigint.max,s=n.find("multipleOf").value??1,a=i/s,c=r/s;return t.utils.random.bigInt({min:a,max:c})*s}},O={schema:Tt,output:({transform:e})=>e.utils.random.boolean()},j={schema:re,output:({def:e,transform:t,context:n})=>t.fromSchema(e.type,n)},F={schema:Ut,output:({def:e,transform:t})=>{const n=t.utils.checks(e.checks),i=n.find("min")?.value??t.defaults.date.min,r=n.find("max")?.value??t.defaults.date.max;return new Date(t.utils.random.int({min:i,max:r}))}},$={schema:ne,output:({def:e,transform:t})=>t.utils.random.boolean()?e.defaultValue():t.fromSchema(e.innerType)},B={schema:G,filter:({def:e})=>e.effect.type==="transform",output:({def:e,transform:t,context:n})=>{if(e.effect.type!=="transform")throw new Error("Must be a transform effect.");const i=t.fromSchema(e.schema,n);return e.effect.transform(i,{addIssue:t.utils.noop,path:[]})}},z={schema:G,filter:({def:e})=>e.effect.type==="preprocess",output:({def:e,transform:t,context:n})=>{if(e.effect.type!=="preprocess")throw new Error("Must be a preprocess effect.");return t.fromSchema(e.schema,n)}},X={schema:G,filter:({def:e})=>e.effect.type==="refinement",output:({def:e,transform:t,context:n})=>{if(e.effect.type!=="refinement")throw new Error("Must be a refinement effect.");const{schema:i}=e;return console.warn(`Because refinements use custom validations, we have no way to accurately manufacture acceptable values. Using the parent type (${i._def.typeName}) to approximate the result.`),t.fromSchema(i,n)}},V={schema:Qt,output:({def:e,transform:t})=>t.utils.random.from(e.values)},K={schema:Yt,output:({def:e,transform:t})=>{const n=e.values??{},i=Object.keys(n).filter(r=>Number.isNaN(Number(r))).map(r=>n[r]);return t.utils.random.from(i)}},W={schema:Ht,output:({transform:e})=>e.utils.noop},P={schema:Vt,output:({def:e,transform:t,context:n})=>{const i=t.fromSchema(e.left,n),r=t.fromSchema(e.right,n),s=b(i,r);if(!s.valid)throw new Error("Intersection is not valid.");return s.data}};function b(e,t){const n=Z(e),i=Z(t);if(e===t)return{valid:!0,data:e};if(n===f.object&&i===f.object){const r=A.objectKeys(t),s=A.objectKeys(e).filter(c=>r.indexOf(c)!==-1),a={...e,...t};for(const c of s){const l=b(e[c],t[c]);if(!l.valid)return{valid:!1};a[c]=l.data}return{valid:!0,data:a}}else if(n===f.array&&i===f.array){if(e.length!==t.length)return{valid:!1};const r=[];for(let s=0;s<e.length;s++){const a=e[s],c=t[s],l=b(a,c);if(!l.valid)return{valid:!1};r.push(l.data)}return{valid:!0,data:r}}else return n===f.date&&i===f.date&&+e==+t?{valid:!0,data:e}:{valid:!1}}const q={schema:M,output:({def:e,transform:t,context:n})=>{const i=t.utils.recursion.get(e.getter)??0;return t.utils.recursion.set(e.getter,i+1),t.fromSchema(e.getter(),n)}},H={schema:Jt,output:({def:e})=>e.value},J={schema:Pt,output:({def:e,transform:t,context:n})=>{const i=e.keyType,r=e.valueType,s=new Map;return t.utils.ifNotNever(i,a=>{t.utils.ifNotNever(r,c=>{t.utils.recursionCheck(c,()=>{t.utils.n(()=>{const l=t.fromSchema(a,n),d=t.fromSchema(c,{...n,path:[...n.path,l]});s.set(l,d)},t.defaults.map)})})}),s}},Q={schema:Rt,output:()=>NaN},Y={schema:jt,output:()=>{throw new Error("Never is a sanity check by Zod to ensure fields don't exist. If we've reached this point, something went wrong during fixture generation.")}},tt={schema:Dt,output:()=>null},et={schema:ee,output:({def:e,transform:t,context:n})=>{let i=null;return t.utils.random.boolean()&&t.utils.recursionCheck(e.innerType,()=>{i=t.fromSchema(e.innerType,n)}),i}},nt={schema:At,output:({def:e,transform:t})=>{const n=t.utils.checks(e.checks),i=n.find("min")??{value:t.defaults.float.min,inclusive:!0},r=n.find("max")??{value:t.defaults.float.max,inclusive:!0},s=i.inclusive?i.value:i.value+1,a=r.inclusive?r.value:r.value-1,c=n.find("multipleOf")?.value,l=n.has("int"),d=n.has("finite");let h=l?t.utils.random.int({min:s,max:a}):t.utils.random.float({min:s,max:a});if(c!==void 0&&(h=Math.round(h/c)*c,h<s&&(h+=c),h>a&&(h-=c),c%1!==0)){const I=c.toString().split(".")[1]?.length;h=Number(h.toFixed(I))}return d&&(h===1/0?h=Number.MAX_VALUE:h===-1/0&&(h=Number.MIN_VALUE)),h}},it={schema:Bt,output:({def:e,transform:t,context:n})=>{const i=e.shape(),r={};for(const a in i)t.utils.ifNotNever(i[a],c=>{t.utils.recursionCheck(c,()=>{r[a]=t.fromSchema(c,{...n,path:[...n.path,a]})})});if(e.unknownKeys==="passthrough"||e.catchall._def.typeName!=="ZodNever"){const a=t.utils.random.lorem(1,"word"),c=e.catchall._def.typeName==="ZodNever"?_.create():e.catchall;r[a]=t.fromSchema(c,{...n,path:[...n.path,a]})}return r}},rt={schema:Wt,output:({def:e,transform:t,context:n})=>{const i={};return t.utils.ifNotNever(e.keyType,r=>{t.utils.ifNotNever(e.valueType,s=>{t.utils.recursionCheck(s,()=>{t.utils.n(()=>{const a=t.fromSchema(r,n),c=t.fromSchema(s,{...n,path:[...n.path,a]});i[a]=c})})})}),i}},st={schema:te,output:({def:e,transform:t,context:n})=>{let i;return t.utils.random.boolean()&&t.utils.recursionCheck(e.innerType,()=>{i=t.fromSchema(e.innerType,n)}),i}},ot={schema:ie,output:({def:e,transform:t,context:n})=>{let i;return t.utils.recursionCheck(e.type,()=>{i=t.fromSchema(e.type,n)}),Promise.resolve(i)}},at={schema:se,output:({transform:e,def:t})=>{const n=e.fromSchema(t.innerType);return Object.freeze(n)}},ct={schema:qt,output:({def:e,transform:t,context:n})=>{const i=e.minSize?.value,r=e.maxSize?.value,s=t.utils.resolveValue({initial:i,fallback:t.defaults.set.min,conflict:r,resolve:l=>Math.min(l.fallback,l.conflict)}),a=t.utils.resolveValue({initial:r,fallback:t.defaults.set.max,conflict:i,resolve:l=>Math.max(l.fallback,l.conflict)}),c=new Set;return t.utils.ifNotNever(e.valueType,l=>{t.utils.recursionCheck(l,()=>{t.utils.n(()=>{c.add(t.fromSchema(l,{...n,path:[...n.path,c.size]}))},{min:s,max:a})})}),c}},ut=e=>`^.{${e.length}}`,Se=e=>`.{${e.length}}$`;function p(e,t,n){const i=e.utils.checks(t.checks);let r=i.find("max")?.value,s=i.find("min")?.value??0;const a=i.find("length")?.value,c=i.find("includes")?.value,l=i.find("startsWith")?.value,d=i.find("endsWith")?.value,h=i.has("emoji"),I=i.has("trim"),Ge=i.has("toUpperCase"),Ne=i.has("toLowerCase");if(a&&(s=a,r=a),s!=null&&n.length<s){const S=s-n.length;n+=e.utils.random.string({min:S,max:S})}if(r!=null&&(n=n.slice(0,r)),c){const S=l?ut(l):"";n=n.replace(new RegExp(`(${S}).{${c.length}}`),(Ee,ke)=>ke+c)}return l&&(n=n.replace(new RegExp(ut(l)),l)),d&&(n=n.replace(new RegExp(Se(d)),d)),Ge?n=n.toUpperCase():Ne&&(n=n.toLowerCase()),I&&(n=n.trim()),h&&(n=n.replace(/./g,()=>e.utils.random.emoji())),r?n.slice(0,r):n}const lt={schema:m,output:({def:e,transform:t})=>{const n=t.utils.checks(e.checks);let i=n.find("min")?.value,r=n.find("max")?.value;const s=n.find("length");return s&&(i=s.value,r=s.value),p(t,e,t.utils.random.string({min:i,max:r}))}},ht={schema:m,filter:({def:e,transform:t})=>t.utils.checks(e.checks).has("ulid"),output:({def:e,transform:t})=>p(t,e,t.utils.random.ulid())},mt={schema:m,filter:({def:e,transform:t})=>t.utils.checks(e.checks).has("url"),output:({def:e,transform:t})=>p(t,e,`https://${t.utils.random.lorem(1)}.com`)},dt={schema:m,filter:({def:e,transform:t})=>t.utils.checks(e.checks).has("uuid"),output:({transform:e})=>e.utils.random.uuid()},ft={schema:m,filter:({def:e,transform:t})=>t.utils.checks(e.checks).has("email"),output:({def:e,transform:t})=>p(t,e,"rando@email.com")},pt={schema:m,filter:({def:e,transform:t})=>t.utils.checks(e.checks).has("cuid"),output:({def:e,transform:t})=>p(t,e,t.utils.random.cuid())},gt={schema:m,filter:({def:e,transform:t})=>t.utils.checks(e.checks).has("ip"),output:({def:e,transform:t})=>(t.utils.checks(e.checks).find("ip")?.version??t.utils.random.from(["v4","v6"]))==="v4"?t.utils.n(()=>t.utils.random.int({min:1,max:255}),4).join("."):t.utils.n(()=>t.utils.random.int({min:0,max:65535}).toString(16),8).join(":")},St={schema:m,filter:({def:e,transform:t})=>t.utils.checks(e.checks).has("cuid2"),output:({def:e,transform:t})=>p(t,e,t.utils.random.cuid2())},vt={schema:m,filter:({def:e,transform:t})=>t.utils.checks(e.checks).has("datetime"),output:({transform:e})=>e.utils.random.date().toISOString()},yt={schema:m,filter:({def:e,transform:t})=>t.utils.checks(e.checks).has("regex"),output:({def:e,transform:t})=>{const n=t.utils.checks(e.checks).find("regex")?.regex;if(!n)throw new Error("RegexGenerator: regex pattern not found");return p(t,e,t.utils.random.regexp(n))}},Gt={schema:Lt,output:({transform:e})=>Symbol.for(e.utils.random.lorem(1,"word"))},Nt={schema:Kt,output:({def:e,transform:t,context:n})=>{const i=[];e.items.forEach((s,a)=>{t.utils.ifNotNever(s,c=>{t.utils.recursionCheck(c,()=>{i.push(t.fromSchema(c,{...n,path:[...n.path,a]}))})})});const r=[];return t.utils.ifNotNever(e.rest,s=>{t.utils.recursionCheck(s,()=>{t.utils.n(a=>r.push(t.fromSchema(s,{...n,path:[...n.path,i.length+a]})),1)})}),[...i,...r]}},kt={schema:Ct,output:()=>{}},bt={schema:Ft,output:()=>{}},xt={schema:zt,output:({def:e,transform:t,context:n})=>{const i=t.utils.random.from(e.options);return t.fromSchema(i,n)}},Et={schema:Xt,output:({def:e,transform:t,context:n})=>{const i=t.utils.random.from(e.options);return t.fromSchema(i,n)}},It={schema:Ot,output:()=>"ZodUnknown"},x=[U,It,st,gt,ht,L,C,D,O,F,V,K,W,P,H,J,Q,tt,nt,it,rt,ct,dt,pt,St,ft,mt,vt,yt,et,Nt,kt,xt,Et,B,z,X,ot,Gt,q,j,bt,Y,lt,$,at];function wt(e){const t=[`No generator found for ${e.constructor.name}.`,"","For z.custom, refer to the documentation https://github.com/timdeschryver/zod-fixture.","If you still believe this is an error, please open an issue at https://github.com/timdeschryver/zod-fixture/issues/new.",""].join(`
`);return new Error(t)}class E extends R{generators=x;missingGeneratorError=wt}class ve extends T{generators=x;missingGeneratorError=wt}function ye(e,t){return new E(t).fromSchema(e)}o.AnyGenerator=U,o.ArrayGenerator=L,o.BigIntGenerator=C,o.BigIntMultipleOfGenerator=D,o.BooleanGenerator=O,o.BrandedGenerator=j,o.ConstrainedFixture=E,o.ConstrainedTransformer=R,o.Cuid2Generator=St,o.CuidGenerator=pt,o.DEFAULT_FIXTURE_GENERATORS=x,o.DateGenerator=F,o.DateTimeGenerator=vt,o.DefaultGenerator=$,o.DiscriminatedUnionGenerator=Et,o.EmailGenerator=ft,o.EnumGenerator=V,o.Fixture=E,o.FunctionGenerator=W,o.Generator=ae,o.IntersectionGenerator=P,o.IpGenerator=gt,o.LazyGenerator=q,o.LiteralGenerator=H,o.MapGenerator=J,o.NanGenerator=Q,o.NativeEnumGenerator=K,o.NeverGenerator=Y,o.NullGenerator=tt,o.NullableGenerator=et,o.NumberGenerator=nt,o.ObjectGenerator=it,o.OptionalGenerator=st,o.PreprocessGenerator=z,o.PromiseGenerator=ot,o.ReadonlyGenerator=at,o.RecordGenerator=rt,o.RefinementGenerator=X,o.RegexGenerator=yt,o.SetGenerator=ct,o.StringGenerator=lt,o.SymbolGenerator=Gt,o.TransformGenerator=B,o.Transformer=k,o.TupleGenerator=Nt,o.UlidGenerator=ht,o.UnconstrainedFixture=ve,o.UnconstrainedTransformer=T,o.UndefinedGenerator=kt,o.UnionGenerator=xt,o.UnknownGenerator=It,o.UrlGenerator=mt,o.UuidGenerator=dt,o.VoidGenerator=bt,o.createFixture=ye,Object.defineProperty(o,Symbol.toStringTag,{value:"Module"})});
